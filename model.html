---
layout: default
---

<section>
    <h1> Model and description of Viua VM </h1>

    <p>
        In theory the implementation should follow a model, but Viua is in
        such an early stage of development that no model exists yet for it.
        Below document is an attempt at creating an abstract model of Viua VM.
    </p>

    <p>
        This document is meant to explain and describe the general concepts and
        ideas behind Viua.
        For example: what is a process, a call frame, a stack, and how are they related.
        Apart from being a glossary of a kind, it also aims to explain how various mechanisms
        are intended to work in Viua, e.g. exception handling (throw-catch), function calls, and
        concurrency.
    </p>

    <p>
        Descriptions of individual instructions are not included in this document, and
        are provided on the <a href="{{ site.url }}/isa.html">ISA description page</a>.
    </p>
</section>

<hr>

<section>
    <h1> Registers and register sets </h1>

    <p>
        Viua is a register-based VM.
        Programs running on it manipulate values held in <em>registers</em> instead of on a <em>stack</em>.
    </p>

    <section>
        <h2> Summary </h2>

        <p>
            On the lowest level, Viua VM programs are sequences of <em>instructions</em>.
            Instruction fetch, manipulate (modify, delete, move, copy, etc.), and produce <em>values</em>.
            Values are stored in <em>registers</em>.
            This section describes what is a register, a register set, and how values can be stored in and
            fetched from registers.
        </p>
    </section>

    <section>
        <h2> Register sets </h2>

        <p>
            A "register set" is array of registers, with limited capacity.
            Size of register sets is determined statically, at compile time.
            There are three main register sets:
        </p>

        <ul>
            <li>local</li>
            <li>static</li>
            <li>global</li>
        </ul>

        <p>
            Values held in registers from these register sets can be manipulated directly by instructions, and
            can be accessed by <code>copy</code>, <code>move</code>, <code>swap</code>, and <code>delete</code>
            instructions.
        </p>

        <p>
            There are also a few "special" register sets (that are not really register sets).
            Values in their registers cannot be manipulated directly, and must be first brought into
            one of the three main register sets.
            These sets are:
        </p>

        <ul>
            <li>
                process' message queue -
                values must be
                <code><a href="{{ site.url }}/isa/receive.html">receive</a></code>-d before use
            </li>
            <li>
                caught slot (exception register) - contains caught exception after a catch block
                has been entered, values must be
                <code><a href="{{ site.url }}/isa/draw.html">draw</a></code>-ed before use
            </li>
        </ul>

        <p>
            All register sets are process-local, meaning that no register set is shared between processes.
        </p>

        <section>
            <h2> Local register set </h2>

            <section>
                <h3> Lifetime </h3>

                <p>
                    This register set's lifetime is bound to the call frame for which it has been spawned, or
                    to the closure for which is has been created.
                    At any point in time there may be many local register sets spawned.
                </p>

                <p>
                    In the first case, the lifetime of the register set (and its registers and their contents) can
                    be statically determined by analysing when the call frame will be popped off the stack.
                </p>

                <p>
                    In the second case, the liftetime is more dynamic since the closure can be returned as a value from
                    a function and thus outlive its original environment.
                    Determining the lifetime of local register set of a closure requires analysing lifetime of the closure,
                    which almost always can be done.
                </p>

                <section>
                    <h4> Creation </h4>

                    <p>
                        Local register sets are spawned either by <code>frame</code>, or by <code>closure</code> instruction.
                        Capacity of register set spawned by <code>frame</code> instruction is stated explicitly.
                        Register set spawned using <code>closure</code> instruction inherits capacity from its enclosing
                        environment.
                    </p>

                    {% highlight lua %}
-- spawn a frame whose local register set will contain 20 registers
-- the frame will accept no parameters
--
--  frame {no-of-parameters} {no-of-local-registers}
frame %0 %20

-- closure stored in register 1, using body of function foo/0
--
--  closure {index-of-register-where-closure-is-stored} {function-implementing-body-of-the-closure}
closure %1 foo/0
                    {% endhighlight %}
                </section>

                <section>
                    <h4> Destruction </h4>

                    <p>
                        Local register sets spawned using <code>frame</code> destroyed when the frame they are associated with
                        is popped off the call stack by <code>return</code> or <code>tailcall</code> instruction, or
                        during stack unwinding when an exception is thrown.
                    </p>

                    <p>
                        Closure-local register sets are destroyed when their closure is destroyed.
                        During lifetime of the closure-local register set it may be pushed to the stack, and
                        popped off it many times without being destroyed.
                        Closures obey the lifetime rules of Viua values, which are described in another section.
                    </p>
                </section>
            </section>

            <section>
                <h3> Access </h3>
                <p>
                    The user program has access to the local register set of only the top-most frame on the stack.
                    It is not possible to access registers in local register set of any frame lower on the stack.
                    Also, contents of local register sets of lower frames do not have any effect on contents of local register sets
                    of the upper frames.
                    Local register sets are isolated from each other, and disposable - they are created anew for every call (closure-local
                    register sets being the exception).
                </p>
            </section>

            <section>
                <h3> Capacity </h3>
                <p>
                    Capacity of each local register set may be different and is determined by the user program.
                    Capacity of local register sets is limited to 4'294'967'296 (2^32) registers.
                </p>
            </section>

            <section>
                <h3> Miscellaneous notes </h3>
                <p>
                    Tail calls do not inherit local register sets of their original frames.
                    They start with a fresh register set.
                </p>
            </section>
        </section>

        <section>
            <h2> Static register set </h2>

            <section>
                <h3> Lifetime </h3>

                <p>
                    Static register sets live as long as the process inside which they have been spawned.
                </p>

                <section>
                    <h4>Creation</h4>

                    <p>
                        Static register sets are created before their first use.
                        This means that they may be spawned eagerly when a process is created for every function that uses a static register set, or
                        lazily - when the runtime detects a function is about to access its static register set.
                        It does not make a difference to the function when the static register set is allocated as long as it can use it.
                    </p>
                </section>

                <section>
                    <h4>Destruction</h4>

                    <p>
                        Static register sets are destroyed after the last frame of a process is popped off the stack, i.e.
                        when the process is no longer able to run any more instructions.
                    </p>
                </section>
            </section>

            <section>
                <h3> Access </h3>
                <p>
                    Static register sets are assigned per-function and are local to a single process.
                    A function <code>foo/0</code> does not have access to static registers of function <code>bar/0</code>.
                    If function <code>foo/0</code> inside process A puts <code>42</code> in first static register, the
                    same function <code>foo/0</code> inside process B will not see that value inside its first static register.
                    The user program also has access only to the static register set of the function function that is currently being executed
                    by the top-most frame on the stack.
                </p>
            </section>

            <section>
                <h3> Capacity </h3>
                <p>
                    Capacity of static register sets is currently fixed at 16 registers.
                </p>
            </section>

            <section>
                <h3> Miscellaneous notes </h3>
                <p>
                    User functions should always check if their static registers are empty before using them.
                    It is a function's responsibility to initialise its own static registers - static <em>register set</em> will
                    be always provided when the function requests it but will be completely empty during the first access.
                    Checking for empty registers can be done using the <code>isnull</code> instruction.
                </p>
            </section>
        </section>

        <section>
            <h2> Global register set </h2>

            <section>
                <h3> Lifetime </h3>
                <p>
                    Global register set's lifetime is bound to a process for which it has been spawned.
                </p>
            </section>

            <section>
                <h3> Access </h3>
                <p>
                    The user program has access to the global register set at all times, and
                    from any call frame on the stack.
                    There are no restrictions similar to those of static or local register sets, except that
                    global register set is spawned per-process and isolated between processes.
                </p>
            </section>

            <section>
                <h3> Capacity </h3>
                <p>
                    Capacity of global register sets is currently fixed at 255 registers.
                </p>
            </section>

            <section>
                <h3> Miscellaneous notes </h3>
                <p>
                    There are no special notes related to the global register set.
                </p>
            </section>
        </section>
    </section>

    <section>
        <h2> Registers </h2>

        <p>
            Registers are "slots" that are used to hold values Viua VM instructions operate on.
            A register can hold any value representable by Viua program, or be empty.
        </p>

        <h3> Register indexes </h3>

        <p>
            Registers are indexed slots in a register set.
            Register indexes start from 0, and go to register set's capacity minus 1.
            For example, a register set with capacity 16 has registers numbered from 0 to 15.
        </p>
    </section>

    <section>
        <h2> Register addressing </h2>

        <p>
            When an instruction wants to fetch a value held in a register, or to put a value in a register,
            it must properly address the register it wants to access.
            If the register address supplied by one of instruction's operands is not valid the VM throws
            an exception.
            To be valid the address must consist of three parts:
        </p>

        <ul>
            <li> a fetch mode </li>
            <li> an index </li>
            <li> a register set specifier </li>
        </ul>

        <section>
            <h2> Register set specifiers </h2>

            <p> Register address must include the register set which should be used. </p>

            <section>
                <h2> Local register set </h2>

                <p>
                    Identified by the <code>local</code>.
                    This register set is resolved at compile time.
                </p>
            </section>

            <section>
                <h2> Static register set </h2>

                <p>
                    Identified by the <code>local</code>.
                    This register set is resolved at compile time.
                </p>
            </section>

            <section>
                <h2> Global register set </h2>

                <p>
                    Identified by the <code>local</code>.
                    This register set is resolved at compile time.
                </p>
            </section>

            <section>
                <h2> "Current" register set </h2>

                <p>
                    Identified by the <code>current</code> .
                    The register set to use is determined at runtime, based
                    on what the "current" register set means at the exact moment in the program.
                    Depending on the state in which the program is "current" may mean that local, static, or
                    global register set may be used.
                </p>
            </section>
        </section>

        <section>
            <h2> Fetch modes </h2>

            <p>
                Fetch mode instructs the VM how it should fetch the value an instruction requests.
                There are three fetch modes: <em>plain</em>, <em>pointer-dereference</em>, and
                <em>register-indirect</em>.
                In source code they are identified by sigils.
            </p>

            <section>
                <h2> "Plain" fetch mode </h2>

                <p>
                    Identified by percent sign - "<code>%</code>".
                </p>

                <p>
                    The simplest fetch mode.
                    It involves just fetching a value from a register at given index from a given register set.
                    For example:
                </p>

                {% highlight lua %}
                    -- print contents of register 1 from local register set
                    print %1 local

                    -- copy contents of register 4 from static register set
                    -- into register 2 from local register set
                    copy %2 local %4 static

                    -- store text in register 1 from global register set
                    text %1 global "Hello World!"
                {% endhighlight %}

                <h3> Box analogy </h3>

                <p>
                    If registers were boxes and values were balls the "plain" fetch mode would mean just
                    taking the ball from a box.
                </p>
            </section>

            <section>
                <h2> "Pointer dereference" fetch mode </h2>

                <p>
                    Identified by star sign - "<code>*</code>".
                </p>

                <p>
                    This mode is composed of two phases.
                    The first one involves fetching a value of a register at specified index from a specified register set.
                    In the second phase the VM dereferences the pointer.
                    <br>
                    The value obtained after dereferencing is the one supplied to the instruction.
                </p>

                <p>
                    Value fetched by the first phase of this mode <strong>MUST</strong> be a pointer.
                    Otherwise the VM throws an exception.
                    An exception is also thrown if the pointer is expired.
                </p>

                <p>
                    An example:
                </p>

                {% highlight lua %}
                    -- store text in register 1 from local register set
                    text %1 local "Hello World!"

                    -- store pointer to a value in register 1 from local register set
                    -- in register 2 from local register set
                    ptr %2 local %1 local

                    -- print the pointer
                    -- "TextPointer" will be printed to standard output
                    print %2 local

                    -- print the value pointed-to by the pointer
                    -- "Hello World!" will be printed to standard output
                    print *2 local
                {% endhighlight %}

                <section>
                    <h3> Pointers to values </h3>

                    <p>
                        It important to note, that <em>Viua pointers <strong>point to values</strong></em>.
                        The code below works even though the text value was moved between taking the pointer to it and
                        dereferencing the pointer.
                    </p>

                    {% highlight lua %}
                        text %1 local "Hello World!"
                        ptr %2 local %1 local

                        -- move the value from register 1 from local register set
                        -- to register 4 from local register set
                        move %4 local %1 local

                        -- this still works and prints "Hello World!"
                        print *2 local
                    {% endhighlight %}
                </section>

                <h3> Box analogy </h3>

                <p>
                    If registers were boxes and values were balls the "plain" fetch mode would mean
                    putting your hand in a box and instead of getting a ball you got a piece of string.
                    You can pull the string to get the ball that is attached to the other end, no matter
                    where the ball currenlty is.
                    Be wary, though, as there is no guarantee that there actually will be a ball attached to
                    the other end of the string (in which case you get an exception)!
                </p>
            </section>

            <section>
                <h2> "Register indirect" fetch mode </h2>

                <p>
                    Identified by "at" sign - "<code>@</code>".
                </p>

                <p>
                    This mode is composed of two phases.
                    The first one involves fetching a value of a register at specified index from a specified register set.
                    In the second phase the VM fetches a value from the register index specified by the integer fetched in the first phase.
                    <br>
                    The second phase fetches from the same register set as the first one.
                    <br>
                    The value obtained after the second fetch is the one supplied to the instruction.
                </p>

                <p>
                    Value fetched by the first phase of this mode <strong>MUST</strong> be an integer.
                    Otherwise the VM throws an exception.
                    An exception is also thrown if the register that would be accessed in the second phase does not exist (i.e. the index is out of bounds), or
                    is empty (i.e. there is no value to be fetched; this is not true for the <code>isnull</code> instruction).
                </p>

                <p>
                    An example:
                </p>

                {% highlight lua %}
                    -- store text in register 1 from local register set
                    text %1 local "Hello World!"

                    -- store integer 1 in register 2 from local register set
                    istore %2 local 1

                    -- print the value using register-indirect fetch mode
                    -- "Hello World!" will be printed to standard output
                    print @2 local
                {% endhighlight %}

                <h3> Box analogy </h3>

                <p>
                    If registers were boxes and values were balls the "plain" fetch mode would mean
                    putting your hand in a box and instead of getting a ball you got a piece of paper
                    with a number written on it, and fetching the ball from a box with the number you
                    read from the piece of paper.
                </p>
            </section>
        </section>

        <section>
            <h2> Common exceptions </h2>

            <p>
                Using empty registers as source operands will result in an exception being thrown by the VM.
                The <code>isnull</code> instruction may be used to check if a register is empty.
            </p>

            <p>
                Accessing "out of range" registers either as destination or source operands will result in an exception being thrown by the VM.
                There is no instruction that can be used to check if a register index is "in range".
            </p>

            <p>
                Using incorrect fetch mode for either destination or source operands will result in an exception being thrown by the VM.
                Sometimes several fetch modes are correct from the VM point of view.
                It is programmer's responsibility to ensure the right fetch mode from their point of view is used.
                For example, for pointers either "plain" or "pointer dereference" fetch mode can be used, but the value supplied to the instruction
                will be different.
            </p>
        </section>
    </section>
</section>

<section>
    <h1> Values </h1>

    <p>
        Values are instances of types supported by Viua VM.
    </p>

    <section>
        <h2> Values as entities </h2>

        <p>
            From the user point of view values are "whole pieces" - VM does not provide instructions to
            access, for example, a third byte of a floating point value.
            If a value is an instance of a compound type (e.g. a vector) the VM may expose instructions to
            access individual elements of the complex value, but each accessed element will be a Viua value.
            There is no way a program may learn about internal structure of a value short of invoking a FFI
            function and then casting the value into a <code>unsigned char*</code> to access the bytes that
            from the value.
        </p>

        <p>
            Also, there is no concept of "memory" in the traditional sense.
            Viua VM programs do not request "eight bytes for an integer", they just request an integer.
            The concept of "memory" is abstracted away in Viua VM.
            Programs cannot put values in "memory", values can only exist in registers.
        </p>
    </section>

    <section>
        <h2> Value semantics </h2>

        <p>
            Viua programs see values as "values" not as "references to values", and
            this rule is applied consistently.
            It is probably most visible during function calls - when vectors are passed by value and
            do not decay into pointers (a la C arrays) or are passed by reference (a la Python lists).
        </p>

        <section>
            <h3> Moves </h3>

            <p>
                To avoid frequent copying which would be implied by the no-references rule, many Viua instructions and
                mechanisms use move semantics instead.
                For example: function returns, and exception throwing are always done by moving values.
            </p>

            <p>
                The thinking behind this is that if you want a copy you can create it yourself before the move happens, but it is not easy
                the other way around, that is: if you wanted a move but the language by default gives you a copy, what can you do about it?
            </p>

            <p>
                Moves in Viua are real moves instead of a "steal-my-guts" moves.
                Moved value <em>really is</em> moved from one place to another, e.g. from one register to another, from a register into a slot in a vector, etc.
            </p>

            <section>
                <h4> Inter-process communication and message passing </h4>

                <p>
                    Some places when moves are <strong><em>not</em></strong> used is message passing and other forms of inter-process communication.
                </p>

                <p>
                    Although, in theory, values <em>could</em> be moved between processes without violating the no-sharing-between-processes rule when sent as messages they are copied.
                    This is done this way to provide consistency as there are no differneces between sending a value to a process running on the same VM instance (i.e.
                    in the same underlying address space) or over a network to a process running in a different VM instance (and different address space).
                </p>

                <p>
                    The same thinking is applied when values are transfered between processes as exceptions or return values during process joins.
                    Even though a value is normally moved in such cases it is copied when return or catch involves crossing process boundaries.
                </p>
            </section>
        </section>
    </section>

    <section>
        <h2> Pointers </h2>
    </section>
</section>
