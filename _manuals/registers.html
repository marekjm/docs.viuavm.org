---
number: 0
title: "Registers and register sets Viua VM programs"
layout: default
id: manuals__registers_and_register_sets
summary: >
    Viua VM programs operate on values held in registers.
---

<section class="chapter">
    <h1> {{ page.title }} </h1>

    <p class="summary">
        {{ page.summary }}
        Instructions fetch values from registers, manipulate them, and store the results of these manipulations back in registers.
        Registers are grouped in three sets: <em>local</em>, <em>static</em>, and <em>global</em>.
        When fetching values for instructions to operate on the VM must know several things:
        the index of a register,
        the register set,
        and the fetch mode.
    </p>

    <p>
        For example, consider code presented below:
    </p>

    {% highlight lua %}
    izero %1 local
    {% endhighlight %}

    <p>
        The "<code>izero</code>" instruction stores integer zero in a register.
        Its abstract form is "<code>izero {:r-operand}</code>".
        "R-operand" is a "register operand", i.e. an operand specifying a register to use for an operation.
        R-operands are used to specify both input and output registers, and their meaning depends on instruction.
        For "<code>izero</code>", the r-operand specifies output register.
        <br>
        For "<code>move</code>" instruction (which moves values between registers) the first r-operand specifies the output register, and
        the second r-operand specifies the input register.
    </p>

    {% highlight lua %}
    move %1 local %2 static
    {% endhighlight %}
</section>

<section>
    <h1> Register sets </h1>

    <p>
        There are three different register sets: <em>local</em>, <em>static</em>, and <em>global</em>.
        The basic difference between them is the length of their lifetime.
        Each set is discussed in detail in its own section.
    </p>

    <hr>

    <section>
        <h2> Local register set </h2>

        <section>
            <h3> Lifetime </h3>
            <p>
                This register set's lifetime is bound to a call-frame for which it has been spawned.
                Local register sets are spawned by <code>frame</code> instructions.
                They are destroyed when the frame they are associated with is popped off the call stack by <code>return</code> or
                <code>tailcall</code> instruction.
            </p>

            <p>
                At any point in time there may be many local register sets spawned.
            </p>
        </section>

        <section>
            <h3> Access </h3>
            <p>
                The user program has access to the local register set of only the top-most frame on the stack.
                It is not possible to access registers in local register set of any frame lower on the stack.
                Also, contents of local register sets of lower frames do not have any effect on contents of local register sets
                of the upper frames.
                Local register sets are isolated from each other, and disposable - they are created anew for every call.
            </p>
        </section>

        <section>
            <h3> Capacity </h3>
            <p>
                Capacity of each local register set may be different and is determined by the user program.
                Capacity of local register sets is limited to 4'294'967'296 (2^32) registers.
            </p>
        </section>

        <section>
            <h3> Misc notes </h3>
            <p>
                Tail calls do not inherit local register sets of their original frames.
            </p>
        </section>
    </section>

    <hr>

    <section>
        <h2> Static register set </h2>

        <section>
            <h3> Lifetime </h3>
            <p>
                Static register set's lifetime is bound to a process inside which it has been spawned.
                Static register sets are assigned per-function and are local to a single process.
                That means that if function <code>foo/0</code> inside process A puts <code>42</code> in first static register, the
                same function <code>foo/0</code> inside process B will not see that value inside its first static register.
            </p>
        </section>

        <section>
            <h3> Access </h3>
            <p>
                The user program has access only to the static register set of the function function that is currently being executed.
                This means that function <code>foo/0</code> does not have access to static registers of function <code>bar/0</code>.
            </p>
        </section>

        <section>
            <h3> Capacity </h3>
            <p>
                Capacity of static register sets is currently fixed at 16 registers.
            </p>
        </section>

        <section>
            <h3> Misc notes </h3>
            <p>
                User functions should always check if their static registers are initialised because there is no guarantee that
                they will be.
                If a function is called inside a new process then it receives a new static register set that is empty.
                Checking for empty registers can be done using the <code>isnull</code> instruction.
            </p>
        </section>
    </section>

    <hr>

    <section>
        <h2> Global register set </h2>

        <section>
            <h3> Lifetime </h3>
            <p>
                Global register set's lifetime is bound to a process for which it has been spawned.
            </p>
        </section>

        <section>
            <h3> Access </h3>
            <p>
                The user program has access to the global register set at all times, and
                from any call frame on the stack.
                There are no restrictions similar to those of static or local register sets, except that
                global register set is spawned per-process and isolated between processes.
            </p>
        </section>

        <section>
            <h3> Capacity </h3>
            <p>
                Capacity of global register sets is currently fixed at 255 registers.
            </p>
        </section>

        <section>
            <h3> Misc notes </h3>
            <p>
                There are no special notes related to the global register set.
            </p>
        </section>
    </section>
</section>
