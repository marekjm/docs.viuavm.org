---
number: 0
title: "Registers and register sets Viua VM programs"
layout: default
id: manuals__registers_and_register_sets
summary: >
    Viua VM programs operate on values held in registers.
---

<section class="chapter">
    <h1> {{ page.title }} </h1>

    <p class="summary">
        {{ page.summary }}
        Instructions fetch values from registers, manipulate them, and store the results of these manipulations back in registers.
        Registers are grouped in three sets: <em>local</em>, <em>static</em>, and <em>global</em>.
        When fetching values for instructions to operate on the VM must know several things:
        the index of a register,
        the register set,
        and the fetch mode.
    </p>

    <p>
        For example, consider code presented below:
    </p>

    {% highlight lua %}
    izero %1 local
    {% endhighlight %}

    <p>
        The "<code>izero</code>" instruction stores integer zero in a register.
        Its abstract form is "<code>izero {:r-operand}</code>".
        "R-operand" is a "register operand", i.e. an operand specifying a register to use for an operation.
        R-operands are used to specify both input and output registers, and their meaning depends on instruction.
        For "<code>izero</code>", the r-operand specifies output register.
        <br>
        For "<code>move</code>" instruction (which moves values between registers) the first r-operand specifies the output register, and
        the second r-operand specifies the input register.
    </p>

    {% highlight lua %}
    move %1 local %2 static
    {% endhighlight %}
</section>

<section>
    <h1> Register sets </h1>

    <p>
        There are three different register sets: <em>local</em>, <em>static</em>, and <em>global</em>.
        The basic difference between them is the length of their lifetime.
        Each set is discussed in detail in its own section.
    </p>

    <hr>

    <section>
        <h2> Local register set </h2>

        <section>
            <h3> Lifetime </h3>
            <p>
                This register set's lifetime is bound to a call-frame for which it has been spawned.
                Local register sets are spawned by <code>frame</code> instructions.
                They are destroyed when the frame they are associated with is popped off the call stack by <code>return</code> or
                <code>tailcall</code> instruction.
            </p>

            <p>
                At any point in time there may be many local register sets spawned.
            </p>
        </section>

        <section>
            <h3> Access </h3>
            <p>
                The user program has access to the local register set of only the top-most frame on the stack.
                It is not possible to access registers in local register set of any frame lower on the stack.
                Also, contents of local register sets of lower frames do not have any effect on contents of local register sets
                of the upper frames.
                Local register sets are isolated from each other, and disposable - they are created anew for every call.
            </p>
        </section>

        <section>
            <h3> Capacity </h3>
            <p>
                Capacity of each local register set may be different and is determined by the user program.
                Capacity of local register sets is limited to 4'294'967'296 (2^32) registers.
            </p>
        </section>

        <section>
            <h3> Misc notes </h3>
            <p>
                Tail calls do not inherit local register sets of their original frames.
            </p>
        </section>
    </section>

    <hr>

    <section>
        <h2> Static register set </h2>

        <section>
            <h3> Lifetime </h3>
            <p>
                Static register set's lifetime is bound to a process inside which it has been spawned.
                Static register sets are assigned per-function and are local to a single process.
                That means that if function <code>foo/0</code> inside process A puts <code>42</code> in first static register, the
                same function <code>foo/0</code> inside process B will not see that value inside its first static register.
            </p>
        </section>

        <section>
            <h3> Access </h3>
            <p>
                The user program has access only to the static register set of the function function that is currently being executed.
                This means that function <code>foo/0</code> does not have access to static registers of function <code>bar/0</code>.
            </p>
        </section>

        <section>
            <h3> Capacity </h3>
            <p>
                Capacity of static register sets is currently fixed at 16 registers.
            </p>
        </section>

        <section>
            <h3> Misc notes </h3>
            <p>
                User functions should always check if their static registers are initialised because there is no guarantee that
                they will be.
                If a function is called inside a new process then it receives a new static register set that is empty.
                Checking for empty registers can be done using the <code>isnull</code> instruction.
            </p>
        </section>
    </section>

    <hr>

    <section>
        <h2> Global register set </h2>

        <section>
            <h3> Lifetime </h3>
            <p>
                Global register set's lifetime is bound to a process for which it has been spawned.
            </p>
        </section>

        <section>
            <h3> Access </h3>
            <p>
                The user program has access to the global register set at all times, and
                from any call frame on the stack.
                There are no restrictions similar to those of static or local register sets, except that
                global register set is spawned per-process and isolated between processes.
            </p>
        </section>

        <section>
            <h3> Capacity </h3>
            <p>
                Capacity of global register sets is currently fixed at 255 registers.
            </p>
        </section>

        <section>
            <h3> Misc notes </h3>
            <p>
                There are no special notes related to the global register set.
            </p>
        </section>
    </section>
</section>

<hr>

<section>
    <h1> Registers </h1>

    <p>
        Registers are "slots" that are used to hold values Viua VM instructions operate on.
        A register can hold any value representable by Viua program, or be empty.
    </p>
</section>

<hr>

<section>
    <h1> Addressing registers </h1>

    <p>
        When an instruction wants to fetch a value held in a register, or to put a value in a register, it must properly address the register it wants to access.
        If the register address supplied by one of instruction's operands is not valid the VM throws an exception.
        To be valid the address must consist of three parts:
    </p>

    <ul>
        <li> a fetch mode </li>
        <li> an index </li>
        <li> a register set specifier </li>
    </ul>

    <p>
        Each part of register address is explained in more detail below.
    </p>

    <section>
        <h2> Register indexes </h2>

        <p> Register indexes are non-negative integers. </p>
    </section>

    <section>
        <h2> Register set specifiers </h2>

        <p> Register address must include the register set which should be used. </p>

        <section>
            <h2> Local register set </h2>

            <p>
                Identified by the <code>local</code>.
                This register set is resolved at compile time.
            </p>
        </section>

        <section>
            <h2> Static register set </h2>

            <p>
                Identified by the <code>local</code>.
                This register set is resolved at compile time.
            </p>
        </section>

        <section>
            <h2> Global register set </h2>

            <p>
                Identified by the <code>local</code>.
                This register set is resolved at compile time.
            </p>
        </section>

        <section>
            <h2> "Current" register set </h2>

            <p>
                Identified by the <code>current</code> .
                This register set is resolved at compile time.
            </p>
        </section>
    </section>

    <section>
        <h2> Fetch modes </h2>

        <p>
            Fetch mode instructs the VM how it should fetch the value an instruction requests.
            Usually, the values are fetched by just obtaining register contents, but may also be more complex.
            It may, for example, involve pointer dereference.
        </p>

        <p>
            There are three fetch modes: <em>plain</em>, <em>pointer-dereference</em>, and <em>register-indirect</em>.
            In source code they are identified by sigils.
        </p>

        <section>
            <h2> "Plain" fetch mode </h2>

            <p>
                Identified by percent sign - "<code>%</code>".
            </p>

            <p>
                The simplest fetch mode.
                It involves just fetching a value from a register at given index from a given register set.
                For example:
            </p>

            {% highlight lua %}
                -- print contents of register 1 from local register set
                print %1 local

                -- copy contents of register 4 from static register set
                -- into register 2 from local register set
                copy %2 local %4 static

                -- store text in register 1 from global register set
                text %1 global "Hello World!"
            {% endhighlight %}
        </section>

        <section>
            <h2> "Pointer dereference" fetch mode </h2>

            <p>
                Identified by star sign - "<code>*</code>".
            </p>

            <p>
                This mode is composed of two phases.
                The first one involves fetching a value of a register at specified index from a specified register set.
                In the second phase the VM dereferences the pointer.
                <br>
                The value obtained after dereferencing is the one supplied to the instruction.
            </p>

            <p>
                Value fetched by the first phase of this mode <strong>MUST</strong> be a pointer.
                Otherwise the VM throws an exception.
                An exception is also thrown if the pointer is expired.
            </p>

            <p>
                An example:
            </p>

            {% highlight lua %}
                -- store text in register 1 from local register set
                text %1 local "Hello World!"

                -- store pointer to a value in register 1 from local register set
                -- in register 2 from local register set
                ptr %2 local %1 local

                -- print the pointer
                -- "TextPointer" will be printed to standard output
                print %2 local

                -- print the value pointed-to by the pointer
                -- "Hello World!" will be printed to standard output
                print *2 local
            {% endhighlight %}

            <section>
                <h3> Pointers to values </h3>

                <p>
                    It important to note, that <em>Viua pointers <strong>point to values</strong></em>.
                    The code below works even though the text value was moved between taking the pointer to it and
                    dereferencing the pointer.
                </p>

                {% highlight lua %}
                    text %1 local "Hello World!"
                    ptr %2 local %1 local

                    -- move the value from register 1 from local register set
                    -- to register 4 from local register set
                    move %4 local %1 local

                    -- this still works and prints "Hello World!"
                    print *2 local
                {% endhighlight %}
            </section>
        </section>

        <section>
            <h2> "Register indirect" fetch mode </h2>

            <p>
                Identified by "at" sign - "<code>@</code>".
            </p>

            <p>
                This mode is composed of two phases.
                The first one involves fetching a value of a register at specified index from a specified register set.
                In the second phase the VM fetches a value from the register index specified by the integer fetched in the first phase.
                <br>
                The second phase fetches from the same register set as the first one.
                <br>
                The value obtained after the second fetch is the one supplied to the instruction.
            </p>

            <p>
                Value fetched by the first phase of this mode <strong>MUST</strong> be an integer.
                Otherwise the VM throws an exception.
                An exception is also thrown if the register that would be accessed in the second phase does not exist (i.e. the index is out of bounds), or
                is empty (i.e. there is no value to be fetched; this is not true for the <code>isnull</code> instruction).
            </p>

            <p>
                An example:
            </p>

            {% highlight lua %}
                -- store text in register 1 from local register set
                text %1 local "Hello World!"

                -- store integer 1 in register 2 from local register set
                istore %2 local 1

                -- print the value using register-indirect fetch mode
                -- "Hello World!" will be printed to standard output
                print @2 local
            {% endhighlight %}
        </section>
    </section>
</section>

<hr>

<section>
    <h1> Common exceptions </h1>

    <p>
        Using empty registers as source operands will result in an exception being thrown by the VM.
        The <code>isnull</code> instruction may be used to check if a register is empty.
    </p>

    <p>
        Accessing "out of range" registers either as destination or source operands will result in an exception being thrown by the VM.
        There is no instruction that can be used to check if a register index is "in range".
    </p>

    <p>
        Using incorrect fetch mode for either destination or source operands will result in an exception being thrown by the VM.
        Sometimes several fetch modes are correct from the VM point of view.
        It is programmer's responsibility to ensure the right fetch mode from their point of view is used.
        For example, for pointers either "plain" or "pointer dereference" fetch mode can be used, but the value supplied to the instruction
        will be different.
    </p>
</section>
